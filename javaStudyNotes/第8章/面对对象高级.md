# 面对对象高级
## 类(静态)变量和类方法
### 类(静态)变量
#### 介绍
类变量也叫静态变量/静态属性，是该类的所有对象共享的变量，任何一个类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它时，修改的也是同一个变量

#### 定义
定义语法：
**访问修饰符 static 数据类型 变量名;**
static 访问修饰符 数据类型 变量名;

#### 访问类变量
**类名.类变量名**
或者 对象名.类变量名[静态变量的访问修饰符的访问权限和是范围 和 普通属性时一样的]
推荐使用 ：类名.类变量名;

#### 类变量使用注意事项和细节讨论
1. 什么时候需要类变量
   当我们**需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量**
2. 类变量与实例变量(普通属性)区别
   **类变量时该类的所有对象共享的**，而实例变量时每个对象独享的
3. 加上static称为类变量或静态变量，否则称为实例变量/普通变量/非静态变量
4. 类变量可以通过 **类名.类变量名** 或者 对象名.类变量名 **来访问**，但java设计者推荐我们使用 类名.类变量名访问
5. 实例变量不能通过 类名.类变量名 方式访问
6. 类变量是在类加载时就初始化了，也就是说，即使没有创建对象，**只要类加载了，就可以使用类变量了。**
7. **类变量的生命周期是随类的加载开始，随着类消亡而销毁。**

### 类方法
#### 介绍
类方法也叫静态方法
**访问修饰符 static 返回类型 方法名(){}**//推荐
static 访问修饰符 返回类型 方法名(){}

#### 类方法调用
**类名.类方法名** 或者对象名.类方法名

#### 注意事项
1. 类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区：**类方法中无this参数，普通方法中隐含this的参数**
2. 类方法可以通过类名调用，也可以通过变量名调用
3. 普通方法和对象有关，需要通过对象名调用，不能通过类名调用。
4. **类方法中不允许使用和对象有关的关键字，如this，super。**
5. 类方法只能访问 静态变量 或 静态方法，普通方法都可以访问
**总结:静态方法，只能访问静态的成员，非静态方法，可以都访问。**

---
## 理解main方法语法
### 解释main方法的形式
**public static void main(String[] args){}**
1. main方法由java虚拟机调用
2. java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public
3. java虚拟机在执行main()方法时不必创建对象，所以方法必须是static
4. 该方法接收String类型的数组参数，该数组中保存着执行java命令时传递给所运行的类的参数

### 特别说明
1. **在main()方法中，我们可以直接调用main方法所在的类的静态方法或静态属性**
2. 但是，不能直接访问该类中的**非静态成员，必须创建该类的一个实例对象**后，才能通过这个对象**去访问**类中的非静态成员

---
## 代码块
### 基本介绍
代码块又称为代码初始化块，属于类中的成员[即是类的一部分]，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来。
但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显示调用，而是加载类时，或创建对象时隐式调用

### 基本语法
[访问修饰符]{
   代码;
};
注意：
1. 修饰符 可选，要写只能写static
2. 代码块分为两类，**使用static修饰的 是静态代码块，没有static修饰的，叫普通代码块**
3. **逻辑语句可以是任何逻辑语句(输入，输出，方法调用，循环，判断等……)**
4. ;号可以写上，也可以省略

### 使用细节
1. **相当于另一种形式的构造器(对构造器的补充机制)，可以做初始化的操作**
2. 场景：如果多个构造器中都有重复的语句，可以抽取到代码块中，提高代码的复用性
3. **static代码块**也叫静态代码块，作用就是对类进行初始化，而且**它随着类的加载而执行，而且只会执行一次**，如果是**普通代码块，每创建一个对象，就执行**
4. **类什么时候被加载(重点)**
   **1. 创建对象实例时(new)**
   **2. 创建子类对象实例，父类也会被加载**
   **3. 使用该类的静态成员时(静态变量，静态方法)**
5. **普通代码块，创建对象实例时，会被隐式调用**。被创建一次，被调用一次，如果只是使用该类的静态成员，普通代码块并不会被执行
**总结：**
   1. static代码块是 **类加载时，执行 只会执行一次**
   2. 普通代码块是在 **创建对象时调用** 创建以此，调用一次
6. 创建一个对象时，类的调用顺序
   1. 父类先调用
   2. 调用静态代码块和静态属性初始化(优先级相同，就近原则)
   3. 调用普通代码块和普通属性初始化(优先级相同，就近原则)
   4. 调用构造方法
   5. **构造方法的最前面其实隐含了super()和调用普通代码块**，静态相关的代码块，属性初始化，在类加载时，就执行完毕了
7. **创建子类对象时(继承关系)的顺序**
   **1. 父类静态代码块(属性)
   2. 子类静态代码块(属性)
   3. 父类构造方法
   4. 子类普通代码块(属性)
   5. 子类构造方法**
8. **静态代码块只能直接调用静态成员，普通代码块可以调用任何成员**

---
## 单例设计模式
### 单例
1. 所谓类的单例设计模式，就是采取一定的方法保证在整个软件系统中，**对某一个类只能存在一个对象实例**，并且**该类只提供一个取得其对象实例的方法**
2. 单例模式有两种(1)饿汉式(2)懒汉式

### 饿汉式
对象，通常是重量级对象，饿汉式可能导致创建了对象，但是没有使用
1. 构造器私有化 -> 防止直接new
2. 类的内部创建对象(该对象是static)
3. 向外暴露一个静态的公用方法
```java
public class SingleTon01 {
    public static void main(String[] args) {
        System.out.println(Cat.getInstance());
    }
}
class Cat {
    private String name;
    private static Cat cat = new Cat("咪咪");
    private Cat(String name) {
        this.name = name;
    }
    public static Cat getInstance() {
        return cat;
    }
    @Override
    public String toString() {
        return "Cat{" +
                "name='" + name + '\'' +
                '}';
    }
}
```

### 懒汉式
1. 构造器私有化 -> 防止直接new
2. 定义一个static静态属性
3. 提供一个public的static方法，可以返回一个对象
```java
public class SingleTon01 {
    public static void main(String[] args) {
        System.out.println(Cat.getInstance());
    }
}
class Cat {
    private String name;
    private static Cat cat;
    private Cat(String name) {
        this.name = name;
    }
    public static Cat getInstance() {
        if (cat == null) {
            cat = new Cat("咪咪");
        }
        return cat;
    }
    @Override
    public String toString() {
        return "Cat{" +
                "name='" + name + '\'' +
                '}';
    }
}
```

### 饿汉式 vs 懒汉式
1. 二者最主要的区别在于**创建对象的时机不同**：懒汉式是在类加载就创建了对象实例，而懒汉式是在使用时才创建
2. **饿汉式不存在线程安全问题**，懒汉式存在线程安全问题
3. **饿汉式存在浪费资源的可能**，因为如果程序员一个对象实例都没有使用，那么饿汉式创建的对象就浪费了，懒汉式是使用时才创建，就不存在这个问题
4. 我们在javaSE标准类中，java.lang.Runtime就是经典的单例模式

---
## final关键字
### 基本介绍
final 中文意思：最后的，最终的
final 可以修饰类，属性，方法和局部变量
1. 当**类不希望被继承时**，可以用final修饰
2. 当**不希望父类的某个方法被子类覆盖**/重写(override)时，可以用final关键字修饰
3. 当**不希望类的某个属性的值被修改**，可以用final修饰
4. 当**不希望某个局部变量被修改**，可以使用final修饰

### 使用细节
1. **final修饰的属性也叫常量**，一般**用XX_XX_XX来命名**
2. final修饰的属性在定义时，**必须赋初值**，并且**以后不能再修改**，赋值可以在以下位置之一
   1. 定义时
   2. 构造器中
   3. 代码块中
3. 如果**final修饰的属性是静态的，则初始化都位置只能是1.定义时2.在静态代码块** 不能在构造器中赋值
4. **final类不能被继承，但是可以实例化对象**
5. 如果类不是final类，但是**含有final方法**，则该**方法虽然不能重写，但是可以被继承**
6. 一般来说，如果一个类已经是final类，就没有必要再将方法修饰final方法
7. **final不能修饰构造方法**
8. **final和static**往往**搭配使用**，效率更高，**底层编译器做了优化处理**
9.  包装类(Integer，Double，Float，Boolean等等都是final)，String也是final类

---
## 抽象(abstract)类
**父类方法的不确定性**
当父类某些方法，**需要声明**，但是又**不确定如何实现时**，可以将其**声明为抽象类方法**，那么这个类就是抽象类
### 介绍
1. 用abstract关键字来修饰一个类时，这个方法就是抽象类
   **访问修饰符 abstract 类名{}**
2. 用abstract 关键字来修饰一个方法时，这个方法就是抽象方法
   **访问修饰符 abstract 返回类型 方法名(形参列表);**//没有方法体
3. 抽象类的价值**更多作用在于设计**，是设计者设计好后，**让子类继承并实现抽象类()**
4. 抽象类，是考官比较爱问的知识点，**在框架和设计模式使用较多**

### 细节
1. **抽象类不能被实例化**
2. 抽象类不一定要包含abstract方法，也就是说，**抽象类可以没有abstract方法**
3. 一旦类**包含了abstract方法**，则这个**类必须要声明为abstract**
4. **abstract只能修饰类和方法**，不能修饰属性和其他的
5. 抽象类可以有任意成员[**抽象类本质还是类**]
6. 抽象方法不能有主体，即不能实现
7. 如果**一个类继承了抽象类**，则**必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类**
8. 抽象方法不能使用private，final和static来修饰，因为这些关键字都是和重写相违背的

### 抽象类最佳实践 - 模板设计模式
要求
1. 有多个类，完成不同的任务job
2. 要求能够得到各自完成任务的时间

---
## 接口(interface)
### 介绍
**接口**就是**给出一些没有实现的方法，封装到一起**，到某个**类要使用的时候**，再根据具体情况**把这些方法写出来**。

**语法：**
```java
interface 接口名{
    属性;
    方法;
}

interface 接口名 extends 接口名{
    属性;
    方法;
}

class 类名 implement 接口{
    自己属性;
    自己方法;
    必须实现的接口的抽象方法
}
```

**小结:**
1. 在j**dk7.0前** 接口里的所有方法都没有方法体，即**都是抽象方法**
2. **jdk8.0后**接口类可以有**静态方法，默认方法使用default关键字修饰**，也就是说接口中可以有方法的具体实现

### 细节
1. **接口不可以被实例**
2. **接口中所有方法是public方法**，接口中抽象方法，可以不用abstract修饰
```java
void aaa();
//实际上是 
//public abstract void aaa();
```
3. 一个**普通类实现接口**，就必须将该接口的**所有方法都实现**
4. **抽象类实现接口，可以不用实现接口的方法**
5. 一个**类**同时**可以实现多个接口**
6. **接口中的属性，只能是final的**，而且 public static final 修饰符
```java
interface IA{
    int i = 1;
    //实际上是
    //public static final int a = 1;(必须初始化)
}
```
7. 接口中**属性**的**访问**形式：**接口名.属性名**
8. 一个**接口不能继承其他类**，但是**可以继承多个别的接口**
9.  接口的**修饰符，只能是public 和默认**，这点和类的修饰符是一样的

### 接口 VS 继承
1. 当**子类继承了父类**，就**自动的拥有了父类的功能**
2. 如果**子类需要拓展功能**，可以通过**实现接口的方式拓展**
3. **可以理解 实现接口 是 对java 单继承机制的一种补充**

#### 解决的问题不同
**继承**的价值主要在于：解决代码的**复用性和可维护性**
**接口**的价值主要在于：设计，**设计好各种规范(方法)**，让其他**类去实现这些方法**

#### 接口比继承更灵活
继承是满足 is - a 的关系，接口只要满足 like - a的关系

#### 接口在一定程度上实现代码解耦(接口规范性+动态绑定)

### 接口的多态
1. 多态参数
2. 多态数组
3. 接口存在多态传递现象

---
## 内部类
### 基本介绍
一个**类的内部又完整的嵌套了另一个类结构**，被嵌套的类称为内部类(inner class)，嵌套其他类的类称为外部类(outer class)，是我们类的第五大成员，内部类**最大的特点**就是**直接访问私有属性，并且可以体现类与类之间的包含关系。**
**类的五大成员：[属性，方法，构造器，代码块，内部类]**
```java
class Outer {
    //属性
    private int i = 1;
    //方法
    public void Say(int i) {
        System.out.println(i);
    }
    //构造器
    public Outer(int i) {
        this.i = i;
    }
    //代码块
    {
        System.out.println("代码块。。。");
    }
    //内部类
    class Inner {
        private int j = 2;
    }
}
```
内部类是学习的难点，同时也是重点，后面看底层源码时，有大量的内部类。

### 基本语法
```java
class Outer{       //外部类
    class Inner{   //内部类

    }
}

class Other{       //其他外部类

}
```

### 分类
#### 定义在外部类的局部位置上(比如方法内)
1. 局部内部类(有类名)
2. **匿名内部类(没有类名，重点！！！)**

#### 定义在外部类的成员位置上
1. 成员内部类(没用static修饰)
2. 静态内部类(使用static修饰)

### 局部内部类的使用
说明：局部内部类时**定义在外部类的局部位置**，比如说方法中，并且**有类名**
1. 可以**直接访问外部类的成员，包含私有的**
2. **不能添加访问修饰符**，因为它的地位就是一个局部变量，局部变量是不能使用修饰符的，但是**可以使用final修饰。**
3. **作用域：仅仅在定义它的方法或代码块中。**
4. 局部内部类---访问--->**外部类的成员** [访问方式：**直接访问**]
5. 外部类---访问--->**局部内部类的成员** [访问方式：**创建对象，再访问**(必须在作用域内)]
6. **外部其他类---不能访问--->局部内部类**(因为 局部内部类地位是一个局部变量)
7. 如果**外部类和局部内部类的成员重名时**，默认遵循**就近原则**，如果想**访问外部类的成员**则可以**使用(外部类名.this.成员)去访问**

#### 记住：
1. 局部内部类定义在方法/代码块中
2. 作用域在方法体或者代码块中
3. 本质仍然是类

### 匿名内部类的使用
说明：匿名内部类是**定义在外部类的局部位置**，比如说方法中，并且**没有类名**
#### 基本语法
```java
new 类或接口(参数列表){
    类体
};
```

#### 使用细节
1. 匿名内部类的语法比较奇特，因为**匿名内部类既是一个类的定义，同时它本身也是一个对象**，从语法上看，它既有定义类的特征，也有创建对象的特征。
2. 可以**直接访问外部类的所有成员**，包含私有的
3. **不能添加访问修饰符**，因为他的**地位就是一个局部变量**
4. **作用域：仅仅在定义它的方法或代码块中**
5. 其他和局部内部类相似 
```java
/*
1. 有一个铃声接口Bell，里面有ring方法
2. 有一个手机类Cellphone，具有闹钟功能alarmClock，参数是Bell类型
3. 测试手机类的闹钟功能，通过匿名内部类(对象)作为参数，打印：懒猪起床了
4. 在传入另外一个匿名内部类(对象)，打印：小伙伴上课了
*/
public class Main {
    public static void main(String[] args) {
        Cellphone cellphone = new Cellphone();
        cellphone.alarmClock(new Bell() {
            @Override
            public void ring() {
                System.out.println("懒猪起床了");
            }
        });
        cellphone.alarmClock(new Bell() {
            @Override
            public void ring() {
                System.out.println("小伙伴上课了");
            }
        });
    }
}
interface Bell {
    void ring();
}
class Cellphone {
    public void alarmClock(Bell bell) {
        bell.ring();
    }
}
```